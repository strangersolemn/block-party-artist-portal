<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Block Party Artist Portal</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: #0a0a1b;
            color: white;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        .app-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 80px;
            gap: 15px;
            padding: 15px;
            height: 100vh;
            width: 100vw;
        }

        .panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            border: 2px solid rgba(239, 77, 153, 0.3);
            overflow: hidden;
            position: relative;
        }

        .panel h2 {
            color: #ef4d99;
            font-size: 1.3rem;
            margin-bottom: 12px;
            text-align: center;
        }

        .frog-display {
            flex: 1;
            background: rgba(239, 77, 153, 0.1);
            border: 2px dashed #ef4d99;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 12px;
            min-height: 0;
            position: relative;
        }

        .frog-display p {
            color: #f9bad1;
            text-align: center;
            padding: 20px;
            font-size: 0.95rem;
        }

        .action-btn {
            background: #2e5130;
            color: white;
            border: none;
            padding: 12px 20px;
            font-size: 0.95rem;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            font-weight: bold;
            margin: 5px 0;
        }

        .action-btn:hover {
            background: #3d6a40;
            transform: translateY(-1px);
        }

        /* DRAWING PANEL - SIMPLE APPROACH */
        .canvas-wrapper {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 0;
            position: relative;
            background: #1a1a2e;
            border-radius: 10px;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: min(100%, calc(100vh - 200px));
            max-height: min(100%, calc(100vh - 200px));
            aspect-ratio: 1 / 1;
            margin: auto;
        }

        /* Drawing canvas - stacked layers */
        .canvas-container canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        .canvas-container .mask-bg {
            z-index: 0;
            pointer-events: none;
        }

        .canvas-container .drawing-layer {
            z-index: 1;
        }

        .canvas-container .outline-overlay {
            z-index: 100;
            pointer-events: none;
        }

        /* Floating tools */
        .floating-tools {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(10, 10, 27, 0.95);
            border: 2px solid #2e5130;
            border-radius: 15px;
            padding: 15px;
            width: 200px;
            max-height: calc(100% - 30px);
            overflow-y: auto;
            z-index: 200;
        }

        .floating-tools h3 {
            color: #2e5130;
            font-size: 1.1rem;
            margin-bottom: 12px;
            text-align: center;
        }

        .tool-group {
            margin-bottom: 15px;
        }

        .tool-group label {
            display: block;
            margin-bottom: 6px;
            color: #f9bad1;
            font-size: 0.85rem;
        }

        .color-palette {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 6px;
        }

        .color-btn {
            width: 100%;
            aspect-ratio: 1;
            border: 2px solid transparent;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .color-btn:hover {
            transform: scale(1.08);
            border-color: white;
        }

        .color-btn.active {
            border-color: #2e5130;
            box-shadow: 0 0 12px rgba(46, 81, 48, 0.6);
        }

        .tool-btn {
            width: 100%;
            padding: 10px;
            margin: 3px 0;
            background: #2e5130;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85rem;
        }

        .tool-btn:hover {
            background: #3d6a40;
        }

        .footer-controls {
            grid-column: 1 / -1;
            display: flex;
            gap: 15px;
            justify-content: center;
            align-items: center;
        }

        .action-btn.primary {
            background: linear-gradient(90deg, #2e5130, #3d6a40);
            padding: 16px 45px;
            font-size: 1.1rem;
        }

        /* Preview composition */
        .preview-canvas {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        @media (max-width: 1024px) {
            .app-container {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto 80px;
                overflow-y: auto;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- LEFT PANEL: Frog Preview -->
        <div class="panel">
            <h2>Your Frog</h2>
            <div class="frog-display" id="frogDisplay">
                <p>Click "Generate Frog" to create a random frog!</p>
            </div>
            <button class="action-btn" onclick="generateFrog()">üé≤ Generate Frog</button>
        </div>

        <!-- RIGHT PANEL: Drawing Canvas -->
        <div class="panel">
            <h2>Draw Your Mask</h2>
            
            <div class="floating-tools">
                <h3>Tools</h3>
                
                <div class="tool-group">
                    <label>Colors</label>
                    <div class="color-palette">
                        <div class="color-btn active" style="background: #000000" onclick="selectColor('#000000', this)"></div>
                        <div class="color-btn" style="background: #ffffff" onclick="selectColor('#ffffff', this)"></div>
                        <div class="color-btn" style="background: #ef4d99" onclick="selectColor('#ef4d99', this)"></div>
                        <div class="color-btn" style="background: #f9bad1" onclick="selectColor('#f9bad1', this)"></div>
                        <div class="color-btn" style="background: #ff0000" onclick="selectColor('#ff0000', this)"></div>
                        <div class="color-btn" style="background: #00ff00" onclick="selectColor('#00ff00', this)"></div>
                        <div class="color-btn" style="background: #0000ff" onclick="selectColor('#0000ff', this)"></div>
                        <div class="color-btn" style="background: #ffff00" onclick="selectColor('#ffff00', this)"></div>
                        <div class="color-btn" style="background: #ff8800" onclick="selectColor('#ff8800', this)"></div>
                        <div class="color-btn" style="background: #8800ff" onclick="selectColor('#8800ff', this)"></div>
                        <div class="color-btn" style="background: #00ffff" onclick="selectColor('#00ffff', this)"></div>
                        <div class="color-btn" style="background: #ff00ff" onclick="selectColor('#ff00ff', this)"></div>
                    </div>
                </div>

                <div class="tool-group">
                    <label>Brush: <span id="brushSizeValue">15</span>px</label>
                    <input type="range" min="1" max="80" value="15" id="brushSize" 
                           oninput="brushSize = this.value; document.getElementById('brushSizeValue').textContent = this.value;"
                           style="width: 100%;">
                </div>

                <div class="tool-group">
                    <button class="tool-btn" onclick="currentTool = 'brush'">üñåÔ∏è Brush</button>
                    <button class="tool-btn" onclick="currentTool = 'eraser'">üßπ Eraser</button>
                    <button class="tool-btn" onclick="clearDrawing()">üóëÔ∏è Clear</button>
                </div>
            </div>

            <div class="canvas-wrapper">
                <div class="canvas-container" id="canvasContainer">
                    <!-- Static background and overlay -->
                    <img src="mask-centered.png" id="maskBgImg" style="position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:0;">
                    <!-- Drawing canvas added by JS -->
                    <img src="cat-outline-centered.png" id="outlineImg" style="position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:100;">
                </div>
            </div>
        </div>

        <!-- FOOTER -->
        <div class="footer-controls">
            <button class="action-btn" onclick="previewCombination()">üëÅÔ∏è Preview Together</button>
            <button class="action-btn primary" onclick="downloadArt()">üíæ Download Mask</button>
        </div>
    </div>

    <script>
        // ============ CONFIG ============
        const CANVAS_SIZE = 2000;  // Internal drawing resolution
        
        // Trait system
        const traitFolders = {
            body: { folder: 'Body_sprites', count: 1 },
            eyes: { folder: 'Eyes_sprites', count: 25 },
            mouth: { folder: 'Mouth_sprites', count: 2 },
            head: { folder: 'Head_sprites', count: 44 },
            clothing: { folder: 'Clothing_sprites', count: 12 }
        };
        
        const colorVariants = [
            { name: 'Green', filter: 'none', weight: 70 },
            { name: 'Blue', filter: 'hue-rotate(92deg) saturate(166%)', weight: 10 },
            { name: 'Red', filter: 'hue-rotate(239deg) saturate(200%)', weight: 8 },
            { name: 'Pink', filter: 'hue-rotate(197deg) saturate(200%)', weight: 7 },
            { name: 'Purple', filter: 'hue-rotate(158deg) saturate(198%)', weight: 5 }
        ];

        // ============ STATE ============
        let drawingCanvas, drawingCtx;
        let isDrawing = false;
        let currentColor = '#000000';
        let brushSize = 15;
        let currentTool = 'brush';
        let lastX = 0, lastY = 0;
        let currentFrogTraits = null;
        let maskClipPath = null;

        // ============ INIT ============
        window.onload = async function() {
            await initDrawingCanvas();
            await loadMaskClipPath();
        };

        async function initDrawingCanvas() {
            const container = document.getElementById('canvasContainer');
            
            // Create drawing canvas and insert between background and outline
            drawingCanvas = document.createElement('canvas');
            drawingCanvas.width = CANVAS_SIZE;
            drawingCanvas.height = CANVAS_SIZE;
            drawingCanvas.style.cssText = 'position:absolute; top:0; left:0; width:100%; height:100%; cursor:crosshair; z-index:50;';
            
            // Insert before the outline image
            const outlineImg = document.getElementById('outlineImg');
            container.insertBefore(drawingCanvas, outlineImg);
            
            drawingCtx = drawingCanvas.getContext('2d');
            
            // Setup drawing events
            drawingCanvas.addEventListener('mousedown', startDrawing);
            drawingCanvas.addEventListener('mousemove', draw);
            drawingCanvas.addEventListener('mouseup', stopDrawing);
            drawingCanvas.addEventListener('mouseout', stopDrawing);
            drawingCanvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            drawingCanvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            drawingCanvas.addEventListener('touchend', stopDrawing);
            
            console.log('Drawing canvas initialized');
        }

        async function loadMaskClipPath() {
            try {
                const response = await fetch('mask-simple.svg');
                const svgText = await response.text();
                const parser = new DOMParser();
                const svgDoc = parser.parseFromString(svgText, 'image/svg+xml');
                const pathElement = svgDoc.querySelector('path');
                
                if (pathElement) {
                    const pathData = pathElement.getAttribute('d');
                    maskClipPath = new Path2D(pathData);
                    console.log('Mask clip path loaded');
                }
            } catch (error) {
                console.error('Error loading mask path:', error);
            }
        }

        // ============ DRAWING ============
        function getCanvasCoords(e) {
            const rect = drawingCanvas.getBoundingClientRect();
            const scaleX = CANVAS_SIZE / rect.width;
            const scaleY = CANVAS_SIZE / rect.height;
            return {
                x: (e.clientX - rect.left) * scaleX,
                y: (e.clientY - rect.top) * scaleY
            };
        }

        function startDrawing(e) {
            isDrawing = true;
            const coords = getCanvasCoords(e);
            lastX = coords.x;
            lastY = coords.y;
        }

        function draw(e) {
            if (!isDrawing) return;
            
            const coords = getCanvasCoords(e);
            
            drawingCtx.lineWidth = brushSize * (CANVAS_SIZE / 500); // Scale brush
            drawingCtx.lineCap = 'round';
            drawingCtx.lineJoin = 'round';
            
            if (currentTool === 'eraser') {
                drawingCtx.globalCompositeOperation = 'destination-out';
                drawingCtx.strokeStyle = 'rgba(0,0,0,1)';
            } else {
                drawingCtx.globalCompositeOperation = 'source-over';
                drawingCtx.strokeStyle = currentColor;
            }
            
            // Apply clipping to mask shape
            drawingCtx.save();
            if (maskClipPath) {
                drawingCtx.scale(CANVAS_SIZE / 8000, CANVAS_SIZE / 8000);
                drawingCtx.clip(maskClipPath);
                drawingCtx.scale(8000 / CANVAS_SIZE, 8000 / CANVAS_SIZE);
            }
            
            drawingCtx.beginPath();
            drawingCtx.moveTo(lastX, lastY);
            drawingCtx.lineTo(coords.x, coords.y);
            drawingCtx.stroke();
            
            drawingCtx.restore();
            
            lastX = coords.x;
            lastY = coords.y;
        }

        function stopDrawing() {
            isDrawing = false;
        }

        function handleTouchStart(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousedown', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            drawingCanvas.dispatchEvent(mouseEvent);
        }

        function handleTouchMove(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousemove', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            drawingCanvas.dispatchEvent(mouseEvent);
        }

        function selectColor(color, btn) {
            currentColor = color;
            document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
        }

        function clearDrawing() {
            drawingCtx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
        }

        // ============ FROG GENERATION ============
        function generateFrog() {
            // Weighted random color selection
            const totalWeight = colorVariants.reduce((sum, c) => sum + c.weight, 0);
            let random = Math.random() * totalWeight;
            let selectedColor = colorVariants[0];
            for (const color of colorVariants) {
                random -= color.weight;
                if (random <= 0) {
                    selectedColor = color;
                    break;
                }
            }
            
            currentFrogTraits = {
                body: 1,
                eyes: Math.floor(Math.random() * traitFolders.eyes.count) + 1,
                mouth: Math.floor(Math.random() * traitFolders.mouth.count) + 1,
                head: Math.floor(Math.random() * traitFolders.head.count) + 1,
                clothing: Math.floor(Math.random() * traitFolders.clothing.count) + 1,
                color: selectedColor
            };
            
            console.log('Generated frog:', currentFrogTraits);
            displayFrog(currentFrogTraits);
        }

        async function displayFrog(traits) {
            const display = document.getElementById('frogDisplay');
            display.innerHTML = '';
            
            const canvas = document.createElement('canvas');
            canvas.width = 500;
            canvas.height = 500;
            canvas.style.maxWidth = '100%';
            canvas.style.maxHeight = '100%';
            display.appendChild(canvas);
            
            const ctx = canvas.getContext('2d');
            
            try {
                // Load sprites
                const sprites = {
                    body: await loadImage(`${traitFolders.body.folder}/${traits.body}body-sprite.avif`),
                    eyes: await loadImage(`${traitFolders.eyes.folder}/${traits.eyes}eyes_sprite.avif`),
                    mouth: await loadImage(`${traitFolders.mouth.folder}/${traits.mouth}Mouth-sprite.avif`),
                    head: await loadImage(`${traitFolders.head.folder}/${traits.head}head_sprite.avif`),
                    clothing: await loadImage(`${traitFolders.clothing.folder}/${traits.clothing}clothing.avif`)
                };
                
                // Draw first frame (static)
                const drawSprite = (img, applyFilter) => {
                    if (applyFilter && traits.color.filter !== 'none') {
                        ctx.filter = traits.color.filter;
                    } else {
                        ctx.filter = 'none';
                    }
                    ctx.drawImage(img, 0, 0, 500, 500, 0, 0, 500, 500);
                };
                
                drawSprite(sprites.body, true);
                drawSprite(sprites.mouth, false);
                drawSprite(sprites.eyes, true);
                drawSprite(sprites.clothing, false);
                drawSprite(sprites.head, false);
                ctx.filter = 'none';
                
            } catch (error) {
                console.error('Error loading frog:', error);
                display.innerHTML = `<p style="color:red;">Error: ${error.message}</p>`;
            }
        }

        function loadImage(url) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = () => reject(new Error(`Failed to load: ${url}`));
                img.src = url;
            });
        }

        // ============ PREVIEW COMBINATION ============
        async function previewCombination() {
            if (!currentFrogTraits) {
                alert('Generate a frog first!');
                return;
            }
            
            const display = document.getElementById('frogDisplay');
            display.innerHTML = '';
            
            // Create composition canvas (1000x1000 to match cat-full.png)
            const canvas = document.createElement('canvas');
            canvas.width = 1000;
            canvas.height = 1000;
            canvas.style.maxWidth = '100%';
            canvas.style.maxHeight = '100%';
            display.appendChild(canvas);
            
            const ctx = canvas.getContext('2d');
            
            try {
                // 1. Draw frog (scaled from 500 to 1000)
                const sprites = {
                    body: await loadImage(`${traitFolders.body.folder}/${currentFrogTraits.body}body-sprite.avif`),
                    eyes: await loadImage(`${traitFolders.eyes.folder}/${currentFrogTraits.eyes}eyes_sprite.avif`),
                    mouth: await loadImage(`${traitFolders.mouth.folder}/${currentFrogTraits.mouth}Mouth-sprite.avif`),
                    head: await loadImage(`${traitFolders.head.folder}/${currentFrogTraits.head}head_sprite.avif`),
                    clothing: await loadImage(`${traitFolders.clothing.folder}/${currentFrogTraits.clothing}clothing.avif`)
                };
                
                const drawSprite = (img, applyFilter) => {
                    if (applyFilter && currentFrogTraits.color.filter !== 'none') {
                        ctx.filter = currentFrogTraits.color.filter;
                    } else {
                        ctx.filter = 'none';
                    }
                    ctx.drawImage(img, 0, 0, 500, 500, 0, 0, 1000, 1000);
                };
                
                drawSprite(sprites.body, true);
                drawSprite(sprites.mouth, false);
                drawSprite(sprites.eyes, true);
                drawSprite(sprites.clothing, false);
                drawSprite(sprites.head, false);
                ctx.filter = 'none';
                
                // 2. Draw cat-full.png (the cat body in bottom-left)
                const catFull = await loadImage('cat-full.png');
                ctx.drawImage(catFull, 0, 0, 1000, 1000);
                
                // 3. Draw user's mask art - REPOSITIONED from centered to bottom-left
                // The drawing canvas is 2000x2000, displaying an 8000x8000 coordinate space
                // The mask-centered.png shows the mask in the CENTER of the 8000x8000 space
                // The cat-outline-positioned.png shows the cat in BOTTOM-LEFT of 1000x1000
                
                // SIMPLE APPROACH: Scale the entire 2000x2000 drawing to fit in bottom-left
                // Cat outline bounding box: x=0-315, y=696-1000 (315x304)
                // But we need to match the mask shape, not cat outline
                
                // The mask in 8000x8000 is roughly centered, taking up about 47% width, 66% height
                // Scale factor from drawing (2000) to preview (1000) = 0.5
                // But we also need to reposition from center to bottom-left
                
                // Cat face area in preview: approximately x=-50 to 350, y=550 to 1050
                // Scale drawing to ~40% and position in bottom-left
                const scale = 0.175;  // Scale drawing down significantly
                const offsetX = -80;  // Shift left 
                const offsetY = 470;  // Shift down to bottom
                
                ctx.drawImage(
                    drawingCanvas,
                    0, 0, 2000, 2000,  // Full source
                    offsetX, offsetY, 2000 * scale, 2000 * scale  // Scaled and positioned
                );
                
                // 4. Draw cat outline on top
                const catOutline = await loadImage('cat-outline-positioned.png');
                ctx.drawImage(catOutline, 0, 0, 1000, 1000);
                
                console.log('Preview composition complete!');
                
            } catch (error) {
                console.error('Error creating preview:', error);
                display.innerHTML = `<p style="color:red;">Error: ${error.message}</p>`;
            }
        }

        // ============ DOWNLOAD ============
        function downloadArt() {
            // Create a canvas with just the masked drawing
            const exportCanvas = document.createElement('canvas');
            exportCanvas.width = CANVAS_SIZE;
            exportCanvas.height = CANVAS_SIZE;
            const exportCtx = exportCanvas.getContext('2d');
            
            // Apply mask clipping
            if (maskClipPath) {
                exportCtx.save();
                exportCtx.scale(CANVAS_SIZE / 8000, CANVAS_SIZE / 8000);
                exportCtx.clip(maskClipPath);
                exportCtx.scale(8000 / CANVAS_SIZE, 8000 / CANVAS_SIZE);
            }
            
            exportCtx.drawImage(drawingCanvas, 0, 0);
            
            if (maskClipPath) {
                exportCtx.restore();
            }
            
            // Download
            const link = document.createElement('a');
            link.download = 'mask-art.png';
            link.href = exportCanvas.toDataURL('image/png');
            link.click();
        }
    </script>
</body>
</html>
